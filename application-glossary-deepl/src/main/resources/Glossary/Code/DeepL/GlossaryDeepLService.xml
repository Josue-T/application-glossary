<?xml version="1.1" encoding="UTF-8"?>

<!--
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
-->

<xwikidoc version="1.5" reference="Glossary.Code.DeepL.GlossaryDeepLService" locale="">
  <web>Glossary.Code.DeepL</web>
  <name>GlossaryDeepLService</name>
  <language/>
  <defaultLanguage/>
  <translation>0</translation>
  <creator>xwiki:XWiki.Admin</creator>
  <parent>Glossary.Code.DeepL.WebHome</parent>
  <author>xwiki:XWiki.Admin</author>
  <originalMetadataAuthor>XWiki.Admin</originalMetadataAuthor>
  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>
  <version>1.1</version>
  <title>GlossaryDeepLService</title>
  <comment/>
  <minorEdit>false</minorEdit>
  <syntaxId>xwiki/2.1</syntaxId>
  <hidden>true</hidden>
  <content/>
  <object>
    <name>Glossary.Code.DeepL.GlossaryDeepLService</name>
    <number>0</number>
    <className>XWiki.ScriptComponentClass</className>
    <guid>a5bbf38c-0e74-4c5c-a659-4b139018fb8e</guid>
    <class>
      <name>XWiki.ScriptComponentClass</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <scope>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>scope</name>
        <number>2</number>
        <prettyName>Scope</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>|wiki|global|user</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </scope>
      <script_content>
        <disabled>0</disabled>
        <editor>Text</editor>
        <name>script_content</name>
        <number>3</number>
        <prettyName>Script</prettyName>
        <restricted>0</restricted>
        <rows>20</rows>
        <size>40</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </script_content>
      <script_language>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>script_language</name>
        <number>1</number>
        <prettyName>Language</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>groovy|python</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </script_language>
    </class>
    <property>
      <scope>wiki</scope>
    </property>
    <property>
      <script_content>package org.xwiki.contrib.glossary.deepl

import com.deepl.api.GlossaryEntries
import com.deepl.api.GlossaryInfo
import com.deepl.api.GlossaryLanguagePair
import com.deepl.api.Translator
import com.xpn.xwiki.XWikiContext
import com.xpn.xwiki.XWikiException
import org.apache.commons.lang3.StringUtils
import org.slf4j.Logger
import org.xwiki.component.annotation.Component
import org.xwiki.component.manager.ComponentManager
import org.xwiki.configuration.ConfigurationSource
import org.xwiki.model.reference.DocumentReference
import org.xwiki.model.reference.ObjectReference
import org.xwiki.query.Query
import org.xwiki.query.QueryManager
import org.xwiki.script.service.ScriptService
import org.xwiki.script.service.ScriptServiceManager

import javax.inject.Inject
import javax.inject.Named
import javax.inject.Provider
import javax.inject.Singleton;

@Component
@Named("glossary.deepl")
@Singleton
public class DeepLGlossaryScriptService implements ScriptService
{
    @Inject
    private Logger logger

    @Inject
    private QueryManager queryManager

    @Inject
    protected Provider&lt;XWikiContext&gt; xwikiContextProvider

    @Inject
    private ComponentManager componentManager

    @Inject
    private ScriptServiceManager scriptServiceManager

    private Translator translator = null
    // Helper
    private static String getDeepLLanguage(String language)
    {
        return language.split('_')[0]
    }

    private Translator getTranslator()
    {
        def deeplScriptService = scriptServiceManager.get("translator.deepl")
        try {
            if (translator == null) {
                String apiKey = deeplScriptService.getApiKey()
                translator = new Translator(apiKey)
            }
        } catch (XWikiException e) {
            logger.error("Error while retrieving API key.", e)
            return null
        }
        return translator
    }

    private static boolean supportsLanguageCombination(List&lt;GlossaryLanguagePair&gt; deeplSupportedGlossaries,
        String sourceLanguage, String targetLanguage)
    {
        for (entry in deeplSupportedGlossaries) {
            if (entry.sourceLanguage == getDeepLLanguage(sourceLanguage) &amp;&amp; entry.targetLanguage ==
                getDeepLLanguage(targetLanguage))
            {
                return true
            }
        }
        return false
    }

    private static List&lt;String&gt; getGlossariesWithName(List&lt;GlossaryInfo&gt; deeplGlossaries, String glossaryName)
    {
        List&lt;String&gt; glossaryIds = []
        deeplGlossaries.each { glossary -&gt;
            if (glossary.name == glossaryName) {
                glossaryIds.add(glossary.glossaryId)
            }
        }
        return glossaryIds
    }

    private String GetGlossaryNamePrefix()
    {
        ConfigurationSource xwikiPropertiesConfiguration =
            componentManager.getInstance(ConfigurationSource.class, 'xwikiproperties')
        String glossariesPrefix = xwikiPropertiesConfiguration.getProperty('deepl.glossaries.prefix', '')
        def wikiPrefix = xwikiContextProvider.get().getWikiId()

        if (StringUtils.isBlank(glossariesPrefix)) {
            return "${wikiPrefix}"
        } else {
            return "${glossariesPrefix}-${wikiPrefix}"
        }
    }
    // Method used by different pages
    def SynchronizeGlossaries()
    {
        getTranslator()
        def context = xwikiContextProvider.get()

        // Start by computing the list of glossaries that we can support
        // Get the list of languages that are supported in the XWiki preferences
        def reference = new DocumentReference(context.getWikiId(), "XWiki", "XWikiPreferences")
        def preferencesDoc = context.getWiki().getDocument(reference, context)
        def preferencesObject = preferencesDoc.getXObject(new ObjectReference('XWiki.XWikiPreferences', reference))
        def missingLanguagesRaw = preferencesObject.getStringValue('languages').split(',')

        def glossaryNamePrefix = GetGlossaryNamePrefix()
        def deeplScriptService = scriptServiceManager.get("translator.deepl")

        try {

            def deeplGlossaries = translator.listGlossaries()
            logger.debug('Fetched the list of registered glossaries : [{}]', deeplGlossaries)
            def deeplSupportedGlossaries = translator.getGlossaryLanguages()
            logger
                .debug('Fetched the list of supported glossary language combinations : [{}]', deeplSupportedGlossaries)

            Map&lt;Locale, List&lt;Locale&gt;&gt; localeCombinations = [:]
            missingLanguagesRaw.each { sourceLanguage -&gt;
                localeCombinations[sourceLanguage] = []
                missingLanguagesRaw.each { targetLanguage -&gt;
                    if (supportsLanguageCombination(deeplSupportedGlossaries, sourceLanguage, targetLanguage)) {
                        localeCombinations[sourceLanguage].add(targetLanguage)
                    }
                }
            }

            localeCombinations.each { sourceLanguage, availableTargetLanguages -&gt;
                availableTargetLanguages.each { targetLanguage -&gt;
                    // Compute the name of the glossary
                    def glossaryName = "${glossaryNamePrefix}-${sourceLanguage}-${targetLanguage}"
                    def deeplSrcLang = deeplScriptService.normalizeLocale(sourceLanguage)
                    def deeplDstLang = deeplScriptService.normalizeLocale(targetLanguage)

                    if (deeplSrcLang == deeplDstLang)  {
                        // In case of the language is 'fr_FR' to 'fr_CH' which is same for deepL
                        return
                    }
                    logger.info('Synchronizing glossary [{}]', glossaryName)

                    // Create the list of terms to be added to the glossary
                    List&lt;String[]&gt; glossaryRawEntries =
                        queryManager.createQuery(
                            "select sourceDoc.title, targetDoc.title from XWikiDocument sourceDoc, XWikiDocument targetDoc, BaseObject glossaryObj where glossaryObj.name = sourceDoc.fullName and glossaryObj.name = targetDoc.fullName and glossaryObj.className = 'Glossary.Code.GlossaryClass' and ((sourceDoc.defaultLanguage = :sourceLanguage and sourceDoc.language = '') or sourceDoc.language = :sourceLanguage) and ((targetDoc.defaultLanguage = :targetLanguage and targetDoc.language = '') or targetDoc.language = :targetLanguage)",
                            Query.HQL)
                            .bindValue('sourceLanguage', sourceLanguage.toString())
                            .bindValue('targetLanguage', targetLanguage.toString())
                            .execute()

                    def glossaryEntries = new GlossaryEntries()
                    List&lt;String&gt; glossaryKeys = []
                    glossaryRawEntries.each { entry -&gt;
                        def trimmedKey = entry[0].trim()
                        def trimmedValue = entry[1].trim()
                        if (!glossaryKeys.contains(trimmedKey)) {
                            glossaryKeys.add(trimmedKey)
                            glossaryEntries[trimmedKey] = trimmedValue
                        }
                    }

                    // Check if the glossary exists. If it's the case, we need to delete it to re-create it
                    getGlossariesWithName(deeplGlossaries, glossaryName).each { glossaryId -&gt;
                        logger.debug('Deleting glossary [{}] with ID [{}]', glossaryName, glossaryId)
                        translator.deleteGlossary(glossaryId)
                    }

                    // Create (or re-create the glossary)
                    logger.debug('Creating glossary [{}]', glossaryName)
                    translator.createGlossary(glossaryName, deeplSrcLang, deeplDstLang, glossaryEntries)
                }
            }

            logger.debug('Finished synchronizing glossaries')
        } catch (Exception e) {
            logger.error('Got unexpected error while synchronizing glossaries : [{}]', e.getMessage(), e)
        }
    }

    List&lt;GlossaryInfo&gt; GetDeeplGlossariesEntries()
    {
        getTranslator()
        def glossaryNamePrefix = GetGlossaryNamePrefix()
        return translator.listGlossaries().stream()
            .filter { entry -&gt; entry.name.startsWith(glossaryNamePrefix)  }
            .toList()
    }

    List&lt;GlossaryLanguagePair&gt; GetDeeplGlossaryiesLanguesPairs()
    {
        getTranslator()
        return translator.getGlossaryLanguages()
    }

    GlossaryEntries GetDeeplGlossariesEntriesDetails(String id)
    {
        getTranslator()
        return translator.getGlossaryEntries(id)
    }
}
</script_content>
    </property>
    <property>
      <script_language>groovy</script_language>
    </property>
  </object>
</xwikidoc>
