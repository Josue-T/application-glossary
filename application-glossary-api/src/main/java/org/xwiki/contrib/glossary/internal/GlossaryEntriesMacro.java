/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 */
package org.xwiki.contrib.glossary.internal;

import java.io.StringReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Provider;
import javax.inject.Singleton;

import org.xwiki.bridge.DocumentAccessBridge;
import org.xwiki.bridge.DocumentModelBridge;
import org.xwiki.component.annotation.Component;
import org.xwiki.contrib.glossary.GlossaryConfiguration;
import org.xwiki.contrib.glossary.GlossaryEntriesMacroParameters;
import org.xwiki.contrib.glossary.GlossaryModel;
import org.xwiki.model.reference.DocumentReference;
import org.xwiki.model.reference.EntityReferenceSerializer;
import org.xwiki.rendering.block.Block;
import org.xwiki.rendering.block.GroupBlock;
import org.xwiki.rendering.block.HeaderBlock;
import org.xwiki.rendering.macro.AbstractMacro;
import org.xwiki.rendering.macro.MacroExecutionException;
import org.xwiki.rendering.parser.Parser;
import org.xwiki.rendering.transformation.MacroTransformationContext;
import org.xwiki.rendering.util.IdGenerator;
import org.xwiki.rendering.util.ParserUtils;

import com.xpn.xwiki.XWikiContext;

/**
 * Display every entry in a glossary.
 *
 * @version $Id$
 * @since 1.0
 */
@Component
@Named(GlossaryEntriesMacro.MACRO_NAME)
@Singleton
public class GlossaryEntriesMacro extends AbstractMacro<GlossaryEntriesMacroParameters>
{
    /**
     * The prefix used for generating glossary titles.
     */
    public static final String GLOSSARY_ENTRY_ID_PREFIX = "GlossaryEntry";

    /**
     * The context key which, if set in the context, indicates that the glossary entries within the glossary whose
     * glossary ID is the suffix of the key are included in the document and should thus be referenced through
     * anchors instead of wiki links.
     */
    public static final String GLOSSARY_ANCHORS_CONTEXT_KEY_TEMPLATE = "glossary-anchors-%s";

    /**
     * Context key used in order to avoid displaying the glossary entries of a given glossary twice.
     */
    public static final String GLOSSARY_ENTRIES_CONTEXT_KEY = "glossary-entries-%s";

    /**
     * The name of the macro.
     */
    public static final String MACRO_NAME = "glossaryEntries";

    /**
     * The description of the macro.
     */
    private static final String DESCRIPTION = "Lists all glossary entries from a glossary, as a list";

    @Inject
    private GlossaryModel glossaryModel;

    @Inject
    private DocumentAccessBridge documentAccessBridge;

    @Inject
    private Provider<XWikiContext> xWikiContextProvider;

    @Inject
    private EntityReferenceSerializer<String> entityReferenceSerializer;

    @Inject
    private GlossaryConfiguration glossaryConfiguration;

    @Inject
    @Named("plain/1.0")
    private Parser plainTextParser;

    private ParserUtils parserUtils = new ParserUtils();

    public GlossaryEntriesMacro()
    {
        super("glossaryEntries", DESCRIPTION, GlossaryEntriesMacroParameters.class);
        setDefaultCategory(DEFAULT_CATEGORY_NAVIGATION);
        // We want the macro to be executed before the glossaryReference macros so that links generated by the
        // glossary references point to contents of this macro instead of glossary entries in other pages.
        setPriority(100);
    }

    @Override
    public List<Block> execute(GlossaryEntriesMacroParameters parameters, String content,
        MacroTransformationContext context) throws MacroExecutionException
    {
        XWikiContext xWikiContext = this.xWikiContextProvider.get();
        Locale locale = xWikiContext.getLocale();
        IdGenerator idGenerator = new IdGenerator();
        List<Block> blocks = new ArrayList<>();

        String glossaryId = parameters.getGlossaryId();
        if (glossaryId == null) {
            glossaryId = glossaryConfiguration.defaultGlossaryId();
        }

        String glossaryAnchorContextKey = String.format(GLOSSARY_ANCHORS_CONTEXT_KEY_TEMPLATE, glossaryId);
        String glossaryEntriesContextKey = String.format(GLOSSARY_ENTRIES_CONTEXT_KEY, glossaryId);

        try {
            Map<Locale, Map<String, DocumentReference>> entriesMap = glossaryModel.getGlossaryEntries(glossaryId);

            if (entriesMap.containsKey(locale) && entriesMap.get(locale).size() > 0
                && !((Boolean) xWikiContext.getOrDefault(glossaryEntriesContextKey, false))) {
                // Drop a key in the context indicating that glossary references to this glossary should be rendered
                // as anchors instead of wiki links.
                xWikiContext.put(glossaryAnchorContextKey, true);
                // Also drop another key indicating that the glossary entries are already displayed, in order to avoid
                // any nested display
                xWikiContext.put(glossaryEntriesContextKey, true);

                // Sort the glossary entries by ascending title
                List<Map.Entry<String, DocumentReference>> entries = new ArrayList<>(entriesMap.get(locale).entrySet());
                entries.sort(Map.Entry.comparingByKey());

                for (Map.Entry<String, DocumentReference> entry : entries) {
                    Map<String, String> nameParameters = new HashMap<String, String>() {
                        {
                            put("id", idGenerator.generateUniqueId(GLOSSARY_ENTRY_ID_PREFIX,
                                entityReferenceSerializer.serialize(entry.getValue())));
                            put("class", "glossary-entries-entry-name");
                        }
                    };
                    StringReader nameReader = new StringReader(entry.getKey());
                    List<Block> nameBlocks = plainTextParser.parse(nameReader).getChildren();
                    parserUtils.removeTopLevelParagraph(nameBlocks);
                    HeaderBlock nameBlock =
                        new HeaderBlock(nameBlocks, parameters.getEntryNameHeaderLevel(), nameParameters);
                    nameReader.close();

                    DocumentModelBridge glossaryEntryDocument =
                        documentAccessBridge.getTranslatedDocumentInstance(entry.getValue());
                    Block definitionBlock = new GroupBlock(glossaryEntryDocument.getXDOM().getChildren(),
                        Collections.singletonMap("class", "glossary-entries-entry-definition"));

                    blocks.add(new GroupBlock(Arrays.asList(nameBlock, definitionBlock),
                        Collections.singletonMap("class", "glossary-entries-entry")));
                }
            }

        } catch (Exception e) {
            throw new MacroExecutionException(String.format("Failed to render Glossary [{}]",
                parameters.getGlossaryId()), e);
        }

        return blocks;
    }

    @Override
    public boolean supportsInlineMode()
    {
        return false;
    }
}
